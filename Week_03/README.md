学习笔记
# 1递归
## 1.1递归的实现、特性以及思维要点
* 通过函数体进行循环
* 一个类比：盗梦空间，每一层梦境就是递归进入下一次，（本地变量）本地的状态只在本层，不会影响上一层或者下一层。如果要返回现实世界，必须一层一层回来。
* 递归java代码模板：
```java
public void recur(int level,int param){
    // terminator 
    if (leveL>MAX_LEVEL){
        //process result 
        return;
    }

    //process current logic 
    process(leveL,param);

    // drill down 
    recur(level:level +1,newParam);

    //reverse current status
}
```

* 思维要点
    * 不要人肉进行递归（最大误区）
        n=1,n=2,n=3列出来，不要把n=4,5...也列出来，一个是列不清楚，二个是浪费时间。而是找下面第二步
    * 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
    * 数学归纳法思维

## 1.2解决问题方法与技巧
* 涉及递归的问题，直接用递归时间复杂度为O(2^n),很费时间了。
* 在“爬楼梯”问题中，使用缓存将已经计算过的结果存起来，将时间复杂度从O(2^n)降到O(n)
* 在“括号生成”问题中，在提交判断不合法后，生成中间结果时，减掉一些没用的分支——剪枝，来减少执行次数。
* 特别关注一些大佬写的代码：如光头哥（StefanPochmann）
* **要找到一种感觉：要学会怎么探索和优化自己的答案。要爱上看别人的代码，“原来这个地方还可以这样写”，注意工整，简单。特别是那种重剑无锋大巧不工的代码的时间，马上就想把他这个代码给抄下来，同时自己练会学会写出来代码也保持这个样子的话。那么你就已经上道了，你学这个课最重要的这种所谓的道就已经学到了。（代码）养成阅读的习惯，和养成模拟和自己不断反复地写，把自己的代码提高，这样一个好的习惯。**

# 2分治、回溯
## 2.1分治、回溯的实现和特性
### 2.1.1 分治
* 拆分子问题，将子结果合并
* 比泛型递归多了一步：将子结果合并(倒数第二步)
### 2.1.2 回溯
* 定义：
> 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。

> 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
> * 找到一个可能存在的正确的答案；
> * 在尝试了所有可能的分步方法后宣告该问题没有答案。
>> 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。 
* 典型的问题：八皇后问题
## 2.2解决问题方法与技巧
* 在Pow(x, n) 问题，使用分治的思想，拆成子问题为 每次减半。这样将原来的时间复杂度O(n)降到O(log n)，注意边界条件的处理。
* 在“子集"问题，使用到了reverse the current status，原因是每一层共用list，每次返回上一次之前需要还原这个list,不然就对上一层的结果产生了影响，导致结果不正确。如果下一层使用list.clone()就不需要reverse the current status。
* 在“电话号码”问题中，子问题数随着可能性变化（循环下钻），递归状态树就变成了多叉树
* 在“N皇后”问题中，涉及的参数比较多（cols,pie,na,用于判断是否攻击到），不满足条件时跳过执行下钻（剪枝），并且需要reverse the current status